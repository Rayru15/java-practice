# String

## 개요
Java의 `String` `class`는 `Object`를 `extends`하는 클래스로서 불변 객체(immutable object)입니다.  
즉, 한 번 생성된 `String` 객체는 그 값을 변경할 수 없으며, 문자열을 수정하는 것처럼 보이는 연산은 실제로 새로운 `String` 객체를 생성해 참조를 변경하는 것입니다.
```java
int num = 5;
num = 7;
```
> 이 연산은 연산 후에 `num`의 메모리 주소가 변경되지 않음

```java
String string = "abc";
string = "def";
```
> 이 연산은 연산 후에 `string`이 가리키는 메모리 주소가 바뀜(참조가 변경됨)

## 순회(forEach)
Java `String` 객체 안의 원소들은 `for` 문을 통해 순회할 수 있습니다.  
다만, `Collection`을 `implements` 하지는 않기 때문에 `forEach` 문이나 `for`를 통해 직접적인 순회는 불가능하고  
`toCharArray()`, `chatAt()` 등을 통한 간접 순회가 가능합니다.
```java
String string = "morc.nsmall.com";
for (char c : string.toCharArray()) {
    System.out.println(c);
}
```

## 연산(concat)
위에서 [**한 번 생성된 `String` 객체는 그 값을 변경할 수 없으며...**](#개요) 라고 하였습니다. 그러면 문자열을 이어 붙이는 `+` 연산은 어떨까요?
```java
String abc = "abc";
String def = "def";
String ghi = "ghi";

String result = abc + def + ghi;
System.out.println(result);
```

문자열을 덧셈할 때마다 새로운 문자열 객체를 생성하게 되므로 메모리와 시간 측면에서 비효율을 초래합니다.  
위의 경우는 문자열이 짧지만, 문자열이 길어지면 성능이 더더욱 저하됩니다.

문자열을 자주 결합(concat)해야 하는 경우 `StringBuilder` 클래스를 사용해 효율적으로 이어붙일 수 있습니다.
```java
StringBuilder sb = new StringBuilder();
result = sb.append(abc)
        .append(def)
        .append(ghi)
        .toString();
```

## 메서드(Method)
- `.toCharArray()`
- `.length()`
- `.contains()`
- `.charAt()`
- `.isEmpty()`, `.isBlank()`
- `.indexOf()`
- `.equals()`
- `.replace()`, `.replaceAll()`
- `.split()`
- `.strip()`, ~~`trim()`~~
- `.substring()`